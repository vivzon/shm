#!/bin/bash

# ==============================================================================
# SHM PANEL - BACKEND ENGINE (shm-manage)
# ==============================================================================
# This script handles all privileged operations for WHM and CPanel.
# It is called via sudo from the PHP frontend.
# ==============================================================================

# Exit on error with logging
set -e

# Configuration
source /etc/shm/config.sh

# Fallback Configuration
if [ -z "$ADMIN_EMAIL" ]; then
    ADMIN_EMAIL="admin@$(hostname -f)"
fi

# Database name from config or default
DB_NAME="${DB_NAME:-shm_panel}"

# ------------------------------------------------------------------------------
# HELPER FUNCTIONS
# ------------------------------------------------------------------------------

# Error handler
handle_error() {
    local exit_code=$?
    local line=$1
    local func=${2:-main}
    
    log_action "[ERROR] Failed at line $line in $func with exit code $exit_code"
    echo "Error occurred. Check logs for details."
    exit $exit_code
}

# Set error trap
trap 'handle_error $LINENO ${FUNCNAME[0]:-main}' ERR

# Log Action
log_action() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> /var/log/shm-manage.log
}

# Input Validation
validate_input() {
    local input="$1"
    local type="$2"
    
    case "$type" in
        username)
            if ! [[ "$input" =~ ^[a-zA-Z0-9_-]{3,32}$ ]]; then
                log_action "[VALIDATION] Invalid username: $input"
                echo "Invalid username format (3-32 chars, alphanumeric, dash, underscore)"
                exit 1
            fi
            ;;
        domain)
            if ! [[ "$input" =~ ^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
                log_action "[VALIDATION] Invalid domain: $input"
                echo "Invalid domain format"
                exit 1
            fi
            ;;
        email)
            if ! [[ "$input" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
                log_action "[VALIDATION] Invalid email: $input"
                echo "Invalid email format"
                exit 1
            fi
            ;;
        db_name)
            if ! [[ "$input" =~ ^[a-zA-Z0-9_]{1,64}$ ]]; then
                log_action "[VALIDATION] Invalid database name: $input"
                echo "Invalid database name (1-64 chars, alphanumeric and underscore)"
                exit 1
            fi
            ;;
        db_user)
            if ! [[ "$input" =~ ^[a-zA-Z0-9_]{1,32}$ ]]; then
                log_action "[VALIDATION] Invalid database user: $input"
                echo "Invalid database user (1-32 chars, alphanumeric and underscore)"
                exit 1
            fi
            ;;
    esac
}

# Safe MySQL Query
safe_mysql_query() {
    local query="$1"
    shift
    local args=("$@")
    
    # Escape arguments for MySQL
    for ((i=0; i<${#args[@]}; i++)); do
        args[i]=$(mysql -N -s -e "SELECT QUOTE('${args[i]}')" | sed "s/^'//;s/'$//")
    done
    
    # Build command
    local cmd="mysql"
    if [ -n "$DB_USER" ] && [ -n "$DB_PASS" ]; then
        cmd="$cmd -u$DB_USER -p$DB_PASS"
    fi
    cmd="$cmd $DB_NAME -e"
    
    # Execute with printf to handle special characters
    printf -v formatted_query "$query" "${args[@]}"
    eval "$cmd \"$formatted_query\""
}

# Create Default Index Page
create_default_index() {
    local DIR="$1"
    local DOMNAME="$2"
    local OWNER="$3"
    
    # Do not overwrite if index.html exists
    if [ -f "$DIR/index.html" ] || [ -f "$DIR/index.php" ]; then
        return
    fi
    
    # Create clean, responsive Coming Soon page
    cat > "$DIR/index.html" << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coming Soon | __DOMAIN__</title>
    <style>
        body { margin: 0; padding: 0; font-family: 'Inter', system-ui, sans-serif; background: #f8fafc; color: #0f172a; display: flex; align-items: center; justify-content: center; height: 100vh; text-align: center; }
        .container { padding: 2rem; max-width: 600px; }
        h1 { margin: 0 0 1rem; font-size: 2.5rem; font-weight: 800; letter-spacing: -0.05rem; background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        p { margin: 0 0 2rem; color: #64748b; font-size: 1.125rem; line-height: 1.6; }
        .badge { display: inline-block; background: #ffffff; padding: 0.5rem 1rem; border-radius: 99px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); border: 1px solid #e2e8f0; font-size: 0.875rem; font-weight: 500; color: #64748b; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Website Under Construction</h1>
        <p>The domain <strong>__DOMAIN__</strong> is successfully registered.<br>A new modern website is coming soon.</p>
        <div class="badge">Powered by SHM Panel</div>
    </div>
</body>
</html>
EOF
    
    # Replace placeholder
    sed -i "s/__DOMAIN__/$DOMNAME/g" "$DIR/index.html"
    
    # Set Permissions (644 for files, 755 for directories)
    chown "$OWNER:$OWNER" "$DIR/index.html"
    chmod 644 "$DIR/index.html"
}

# Safe PHP-FPM Reload
safe_reload_php() {
    # Sleep 5s to allow PHP script to finish request and close connection
    nohup bash -c "sleep 5; systemctl reload php8.2-fpm" >/dev/null 2>&1 &
}

# Safe Nginx Reload (Prevents Crash)
safe_nginx_reload() {
    # 1. Verify Config
    if ! nginx -t > /dev/null 2>&1; then
        log_action "[CRITICAL] Nginx Config Check Failed! Aborting Reload."
        nginx -t  # Show actual error
        return 1
    fi

    # 2. Verify Log Directories
    if [ -n "$USER" ] && [ -d "/var/www/clients/$USER" ]; then
        if [ ! -d "/var/www/clients/$USER/logs" ]; then
            mkdir -p "/var/www/clients/$USER/logs"
            chown "$USER:$USER" "/var/www/clients/$USER/logs"
            chmod 755 "/var/www/clients/$USER/logs"
            log_action "Restored missing log directory for $USER"
        fi
    fi

    systemctl reload nginx
}

# Standardize Docroot Path
get_docroot() {
    local USER="$1"
    local DOM="$2"
    local DOCROOT_DB="$3"
    
    if [ -n "$DOCROOT_DB" ] && [ -d "$DOCROOT_DB" ]; then
        echo "$DOCROOT_DB"
    else
        # Standard directory structure
        echo "/var/www/clients/$USER/domains/$DOM/public_html"
    fi
}

# ------------------------------------------------------------------------------
# DOMAIN MANAGEMENT FUNCTIONS (Integrated from shm-domain-commands.sh)
# ------------------------------------------------------------------------------

cmd_add_domain() {
    local domain="$1"
    local username="$2"
    local php_version="${3:-8.2}"

    if [[ -z "$domain" || -z "$username" ]]; then
        echo "Usage: shm-manage add-domain <domain> <username> [php_version]"
        return 1
    fi

    # Call the domain creation script
    # Fallback to local script if /usr/local/bin not present (dev env)
    if [[ -x "/usr/local/bin/add-domain" ]]; then
        /usr/local/bin/add-domain "$domain" "$username" "$php_version"
    elif [[ -x "$(dirname "$0")/add-domain.sh" ]]; then
        "$(dirname "$0")/add-domain.sh" "$domain" "$username" "$php_version"
    else
        echo "Error: add-domain script not found"
        return 1
    fi
    
    # Post-creation: Sync DNS
    local dom_id
    dom_id=$(mysql -N -s -e "SELECT id FROM domains WHERE domain='$domain'" "$DB_NAME" 2>/dev/null || echo "")
    if [ -n "$dom_id" ]; then
        $0 dns-tool sync "$dom_id"
    fi
}

cmd_remove_domain() {
    local domain="$1"
    local force="${2:-no}"

    if [[ -z "$domain" ]]; then
        echo "Usage: shm-manage remove-domain <domain> [--force]"
        return 1
    fi
    
    # We use internal logic here as remove-domain might not be a separate script yet,
    # or is implemented here. DOMAIN_SYSTEM_SUMMARY says cmd_remove_domain is in shm-domain-commands.sh
    
    local clients_base="/var/www/clients"
    local domain_path="$clients_base/$domain"
    local nginx_sites_available="/etc/nginx/sites-available"
    local nginx_sites_enabled="/etc/nginx/sites-enabled"
    local php_fpm_pool_dir="/etc/php"

    echo "[INFO] Removing domain: $domain"

    # Confirm deletion (unless --force)
    if [[ "$force" != "--force" ]]; then
        # For non-interactive automation, we might need to skip this check or rely on flag
        # Assuming CLI usage validation is done upstream
        :
    fi

    # Remove Nginx configuration
    echo "[INFO] Removing Nginx configuration..."
    rm -f "$nginx_sites_enabled/$domain.conf"
    rm -f "$nginx_sites_available/$domain.conf"

    # Remove PHP-FPM pool (all versions)
    echo "[INFO] Removing PHP-FPM pools..."
    find "$php_fpm_pool_dir" -name "$domain.conf" -delete 2>/dev/null || true
    
    # Reload PHP-FPM (try all common versions)
    systemctl reload php8.2-fpm 2>/dev/null || true
    systemctl reload php8.1-fpm 2>/dev/null || true

    # Remove domain directory
    echo "[INFO] Removing domain files..."
    if [[ -d "$domain_path" ]]; then
        # Create backup before deletion
        local backup_file="/var/backups/shm-panel-$domain-$(date +%s).tar.gz"
        mkdir -p /var/backups
        tar -czf "$backup_file" -C "$clients_base" "$domain" 2>/dev/null && \
            echo "[INFO] Backup created: $backup_file"
        
        # Remove domain directory
        rm -rf "$domain_path"
    fi

    # Reload Nginx
    echo "[INFO] Reloading Nginx..."
    if nginx -t && systemctl reload nginx; then
        echo "[SUCCESS] Domain removed successfully"
        return 0
    else
        echo "[ERROR] Failed to reload Nginx"
        return 1
    fi
}

cmd_convert_htaccess() {
    local domain_path="$1"
    
    if [[ -x "/usr/local/bin/htaccess-converter" ]]; then
        /usr/local/bin/htaccess-converter "$domain_path"
    elif [[ -x "$(dirname "$0")/htaccess-converter.sh" ]]; then
        "$(dirname "$0")/htaccess-converter.sh" "$domain_path"
    else
        echo "[ERROR] htaccess-converter script not found"
        return 1
    fi
}

cmd_list_domains() {
    local username="${1:-}"
    local clients_base="/var/www/clients"

    if [[ -z "$username" ]]; then
        # All domains (User directories that look like domains or contain public_html?)
        # With new structure, domains are at /var/www/clients/domain.com
        # But user homes are also there?
        ls -1 "$clients_base" | grep "\." # Simple heuristic for domains
    else
        # Find domains owned by user
        # We can use DB or file ownership
        find "$clients_base" -maxdepth 1 -mindepth 1 -type d | while read dir; do
            if [ "$(stat -c '%U' "$dir")" == "$username" ]; then
                basename "$dir"
            fi
        done
    fi
}


# ------------------------------------------------------------------------------
# MAIN COMMAND HANDLER
# ------------------------------------------------------------------------------

case "$1" in

    # --------------------------------------------------------------------------
    # ACCOUNT MANAGEMENT
    # --------------------------------------------------------------------------
    create-account)
        # $2: user, $3: domain, $4: email, $5: pass
        USER="$2"
        DOM="$3"
        EMAIL="$4"
        PASS="$5"
        
        # Validate inputs
        validate_input "$USER" "username"
        validate_input "$DOM" "domain"
        validate_input "$EMAIL" "email"
        
        if id "$USER" &>/dev/null; then 
            echo "User exists"
            exit 1
        fi
        
        log_action "Creating account: $USER ($DOM)"
        
        # 1. Create System User
        # We use /home/$USER to avoid conflict with /var/www/clients/$DOMAIN
        useradd -m -d "/home/$USER" -s /bin/bash "$USER"
        echo "$USER:$PASS" | chpasswd
        
        # Create user ssh dir
        mkdir -p "/home/$USER/.ssh"
        chmod 700 "/home/$USER/.ssh"
        chown -R "$USER:$USER" "/home/$USER"

        # Add www-data to user group for file manager access
        usermod -a -G "$USER" www-data
        
        # 2. Add Domain (using new script)
        cmd_add_domain "$DOM" "$USER" "8.2"
        
        log_action "Created account: $USER ($DOM)"
        echo "Account created successfully"
        ;;

    delete-account)
        # $2: user
        USER="$2"
        
        validate_input "$USER" "username"
        
        log_action "Deleting account: $USER"
        
        # Find all domains for this user and remove them
        # We query the DB for domains owned by this user
        # Note: We depend on DB here
        mysql -N -s -e "SELECT domain FROM domains d JOIN clients c ON d.client_id=c.id WHERE c.username='$USER'" "$DB_NAME" 2>/dev/null | while read DOM; do
            if [ -n "$DOM" ]; then
                cmd_remove_domain "$DOM" "--force"
            fi
        done
        
        # Remove System User
        pkill -9 -u "$USER" 2>/dev/null || true
        userdel -r "$USER" 2>/dev/null || true
        
        log_action "Deleted account: $USER"
        echo "Account deleted"
        ;;

    add-domain)
        # $2: user, $3: domain
        USER="$2"
        DOM="$3"
        cmd_add_domain "$DOM" "$USER"
        echo "Domain added successfully"
        ;;

    remove-domain|delete-domain)
        # $2: user (ignored in new system as we lookup by domain, but keeping arg for compat), $3: domain
        DOM="$3"
        cmd_remove_domain "$DOM" "--force"
        echo "Domain deleted"
        ;;
    
    convert-htaccess)
        cmd_convert_htaccess "$2"
        ;;
        
    list-domains)
        cmd_list_domains "$2"
        ;;

    suspend-account)
        # $2: user
        USER="$2"
        
        validate_input "$USER" "username"
        
        log_action "Suspending account: $USER"
        
        # Find all domains for this user
        mysql -N -s -e "SELECT domain FROM domains d JOIN clients c ON d.client_id=c.id WHERE c.username='$USER'" "$DB_NAME" 2>/dev/null | while read DOM; do
            if [ -n "$DOM" ]; then
                rm -f "/etc/nginx/sites-enabled/$DOM"
            fi
        done
        
        # Disable PHP Pool
        if [ -f "/etc/php/8.2/fpm/pool.d/$USER.conf" ]; then
            mv "/etc/php/8.2/fpm/pool.d/$USER.conf" "/etc/php/8.2/fpm/pool.d/$USER.conf.disabled"
        fi
        
        # Kill processes
        pkill -9 -u "$USER" 2>/dev/null || true
        
        safe_nginx_reload
        nohup bash -c "sleep 2; systemctl reload php8.2-fpm" >/dev/null 2>&1 &
        
        log_action "Suspended account: $USER"
        echo "Account suspended"
        ;;

    unsuspend-account)
        # $2: user
        USER="$2"
        
        validate_input "$USER" "username"
        
        log_action "Unsuspending account: $USER"
        
        # Find all domains for this user
        mysql -N -s -e "SELECT domain FROM domains d JOIN clients c ON d.client_id=c.id WHERE c.username='$USER'" "$DB_NAME" 2>/dev/null | while read DOM; do
            if [ -n "$DOM" ] && [ -f "/etc/nginx/sites-available/$DOM" ]; then
                ln -sf "/etc/nginx/sites-available/$DOM" "/etc/nginx/sites-enabled/"
            fi
        done
        
        # Enable PHP Pool
        if [ -f "/etc/php/8.2/fpm/pool.d/$USER.conf.disabled" ]; then
            mv "/etc/php/8.2/fpm/pool.d/$USER.conf.disabled" "/etc/php/8.2/fpm/pool.d/$USER.conf"
        fi
        
        safe_nginx_reload
        nohup bash -c "sleep 2; systemctl reload php8.2-fpm" >/dev/null 2>&1 &
        
        log_action "Unsuspended account: $USER"
        echo "Account unsuspended"
        ;;

    reset-account)
        # $2: user
        USER="$2"
        
        validate_input "$USER" "username"
        
        log_action "Resetting account: $USER"
        
        # 1. Get Client ID
        CID=$(mysql -N -s -e "SELECT id FROM clients WHERE username='$USER'" "$DB_NAME" 2>/dev/null || echo "")
        
        if [ -n "$CID" ]; then
            # 2. Drop Databases
            mysql -N -s -e "SELECT db_name FROM client_databases WHERE client_id=$CID" "$DB_NAME" 2>/dev/null | while read DB; do
                if [ -n "$DB" ]; then
                    mysql -e "DROP DATABASE IF EXISTS \`$DB\`;" 2>/dev/null || true
                    log_action "Dropped DB (Reset): $DB"
                fi
            done
        fi
        
        # 3. Wipe Web Content (all domains)
        if [ -d "/var/www/clients/$USER/domains" ]; then
            find "/var/www/clients/$USER/domains" -mindepth 2 -maxdepth 2 -name "public_html" -type d | while read DOCROOT; do
                DOM=$(basename "$(dirname "$DOCROOT")")
                rm -rf "$DOCROOT"/*
                create_default_index "$DOCROOT" "$DOM" "$USER"
            done
        fi
        
        log_action "Reset Account: $USER"
        echo "Account reset completed"
        ;;

    # --------------------------------------------------------------------------
    # PERMISSION FIX TOOL
    # --------------------------------------------------------------------------
    fix-permissions)
        # $2: user
        USER="$2"
        
        validate_input "$USER" "username"
        
        HOME_DIR="/var/www/clients/$USER"
        
        if [ ! -d "$HOME_DIR" ]; then
            echo "User directory not found"
            exit 1
        fi
        
        log_action "Starting Permission Fix for $USER"
        
        # 1. Reset Ownership
        chown -R "$USER:$USER" "$HOME_DIR"
        
        # 2. Reset Base Permissions
        find "$HOME_DIR" -type d -exec chmod 755 {} \;
        find "$HOME_DIR" -type f -exec chmod 644 {} \;
        
        # 3. Special Handling for Web Directories
        if [ -d "$HOME_DIR/domains" ]; then
            find "$HOME_DIR/domains" -mindepth 2 -maxdepth 2 -name "public_html" -type d | while read WEBROOT; do
                # Set proper ownership and permissions
                chown -R "$USER:www-data" "$WEBROOT"
                find "$WEBROOT" -type d -exec chmod 775 {} \;
                find "$WEBROOT" -type d -exec chmod g+s {} \;
                find "$WEBROOT" -type f -exec chmod 664 {} \;
            done
        fi
        
        # 4. Logs Directory
        if [ -d "$HOME_DIR/logs" ]; then
            chmod 755 "$HOME_DIR/logs"
            chown "$USER:$USER" "$HOME_DIR/logs"/*
        fi
        
        # 5. Ensure www-data is in group
        usermod -a -G "$USER" www-data
        
        # 6. SSH Directory
        if [ -d "$HOME_DIR/.ssh" ]; then
            chmod 700 "$HOME_DIR/.ssh"
            chmod 600 "$HOME_DIR/.ssh/"* 2>/dev/null || true
        fi
        
        log_action "Fixed Permissions for: $USER"
        echo "Permissions fixed successfully"
        ;;

    # --------------------------------------------------------------------------
    # MYSQL TOOL
    # --------------------------------------------------------------------------
    mysql-tool)
        SUB="$2"
        
        case "$SUB" in
            create-db)
                # $3: db_name
                DB_NAME_VAL="$3"
                validate_input "$DB_NAME_VAL" "db_name"
                
                mysql -e "CREATE DATABASE IF NOT EXISTS \`$DB_NAME_VAL\` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;" || exit 1
                log_action "Created DB: $DB_NAME_VAL"
                echo "Database created"
                ;;
                
            create-user)
                # $3: db_user, $4: db_pass, $5: target_db
                DB_USER_VAL="$3"
                DB_PASS="$4"
                TARGET_DB="$5"
                
                validate_input "$DB_USER_VAL" "db_user"
                validate_input "$TARGET_DB" "db_name"
                
                # Escape password for MySQL
                ESCAPED_PASS=$(mysql -N -s -e "SELECT QUOTE('$DB_PASS')" | sed "s/^'//;s/'$//")
                
                mysql -e "CREATE USER IF NOT EXISTS '$DB_USER_VAL'@'localhost' IDENTIFIED BY '$ESCAPED_PASS';" || { echo "Error: Create User Failed"; exit 1; }
                mysql -e "GRANT ALL PRIVILEGES ON \`$TARGET_DB\`.* TO '$DB_USER_VAL'@'localhost';" || { echo "Error: Grant Failed"; exit 1; }
                mysql -e "FLUSH PRIVILEGES;"
                log_action "Created DB User: $DB_USER_VAL for $TARGET_DB"
                echo "Database user created"
                ;;
                
            delete-db)
                # $3: db_name
                DB_NAME_VAL="$3"
                validate_input "$DB_NAME_VAL" "db_name"
                
                mysql -e "DROP DATABASE IF EXISTS \`$DB_NAME_VAL\`;" || exit 1
                log_action "Dropped DB: $DB_NAME_VAL"
                echo "Database deleted"
                ;;
                
            reset-pass)
                # $3: db_user, $4: new_pass
                DB_USER_VAL="$3"
                NEW_PASS="$4"
                
                validate_input "$DB_USER_VAL" "db_user"
                ESCAPED_PASS=$(mysql -N -s -e "SELECT QUOTE('$NEW_PASS')" | sed "s/^'//;s/'$//")
                
                mysql -e "ALTER USER '$DB_USER_VAL'@'localhost' IDENTIFIED BY '$ESCAPED_PASS';" || { echo "Error: Password Reset Failed"; exit 1; }
                mysql -e "FLUSH PRIVILEGES;"
                log_action "Reset Pass DB User: $DB_USER_VAL"
                echo "Password reset"
                ;;
                
            delete-user)
                # $3: db_user
                DB_USER_VAL="$3"
                validate_input "$DB_USER_VAL" "db_user"
                
                mysql -e "DROP USER IF EXISTS '$DB_USER_VAL'@'localhost';" || echo "User drop failed or not found"
                log_action "Deleted DB User: $DB_USER_VAL"
                echo "Database user deleted"
                ;;
                
            *)
                echo "Unknown mysql-tool subcommand: $SUB"
                exit 1
                ;;
        esac
        ;;

    # --------------------------------------------------------------------------
    # DNS TOOL
    # --------------------------------------------------------------------------
    dns-tool)
        SUB="$2"
        
        if [ "$SUB" == "sync" ]; then
            # $3: domain_id
            DOM_ID="$3"
            DOM_INFO=$(mysql -N -s -e "SELECT domain FROM domains WHERE id=$DOM_ID" "$DB_NAME" 2>/dev/null || echo "")
            
            if [ -z "$DOM_INFO" ]; then
                echo "Domain not found"
                exit 1
            fi
            
            # Create zones directory if it doesn't exist
            mkdir -p "/etc/bind/zones"
            
            # Generate Zone File
            ZONE_FILE="/etc/bind/zones/db.$DOM_INFO"
            
            # Get server IP
            SERVER_IP=$(hostname -I | awk '{print $1}')
            
            cat > "$ZONE_FILE" << EOF
\$TTL 86400
@ IN SOA ns1.$MAIN_DOMAIN. $ADMIN_EMAIL. ( $(date +%Y%m%d)01 3600 900 604800 86400 )
@ IN NS ns1.$MAIN_DOMAIN.
@ IN NS ns2.$MAIN_DOMAIN.
@ IN A $SERVER_IP
www IN CNAME @
mail IN A $SERVER_IP
ftp IN CNAME @
EOF

            # Add nameserver glue records for main domain
            if [ "$DOM_INFO" == "$MAIN_DOMAIN" ]; then
                echo "ns1 IN A $SERVER_IP" >> "$ZONE_FILE"
                echo "ns2 IN A $SERVER_IP" >> "$ZONE_FILE"
                log_action "Added Nameserver Glue Records for $DOM_INFO"
            fi
            
            # Append custom DNS records from DB
            mysql -N -B -e "SELECT host, type, value, priority FROM dns_records WHERE domain_id=$DOM_ID" "$DB_NAME" 2>/dev/null | while IFS=$'\t' read -r host type value priority; do
                if [ -n "$host" ] && [ -n "$type" ] && [ -n "$value" ]; then
                    case "$type" in
                        MX)
                            echo "$host IN MX $priority $value" >> "$ZONE_FILE"
                            ;;
                        TXT)
                            # Clean and quote TXT values
                            clean_val="${value//\"/\\\"}"
                            echo "$host IN TXT \"$clean_val\"" >> "$ZONE_FILE"
                            ;;
                        CNAME|A|AAAA)
                            echo "$host IN $type $value" >> "$ZONE_FILE"
                            ;;
                    esac
                fi
            done
            
            # Add to named.conf.local if not already present
            if ! grep -q "zone \"$DOM_INFO\"" /etc/bind/named.conf.local; then
                cat >> /etc/bind/named.conf.local << EOF
zone "$DOM_INFO" {
    type master;
    file "$ZONE_FILE";
    allow-transfer { none; };
    allow-query { any; };
};
EOF
            fi
            
            # Set proper permissions
            chown bind:bind "$ZONE_FILE"
            chmod 644 "$ZONE_FILE"
            
            # Reload BIND
            if systemctl is-active --quiet bind9; then
                rndc reload > /dev/null 2>&1 || systemctl reload bind9
            fi
            
            log_action "Synced DNS for $DOM_INFO"
            echo "DNS zone updated"
        else
            echo "Unknown dns-tool subcommand: $SUB"
            exit 1
        fi
        ;;

    # --------------------------------------------------------------------------
    # VHOST TOOL (PHP Version & SSL Switcher)
    # --------------------------------------------------------------------------
    vhost-tool)
        SUB="$2"
        
        if [ "$SUB" == "sync" ]; then
            # $3: domain_id
            DOM_ID="$3"
            
            # Get domain info
            read DOM USER PHP_VER SSL DOCROOT_DB <<< $(mysql -N -s -e "SELECT d.domain, c.username, d.php_version, d.ssl_active, d.document_root FROM domains d JOIN clients c ON d.client_id=c.id WHERE d.id=$DOM_ID" "$DB_NAME" 2>/dev/null || echo "")
            
            if [ -z "$DOM" ] || [ -z "$USER" ]; then
                echo "Domain or user not found"
                exit 1
            fi
            
            # Determine DOCROOT
            DOCROOT=$(get_docroot "$USER" "$DOM" "$DOCROOT_DB")
            
            # Create directory if it doesn't exist
            mkdir -p "$DOCROOT"
            
            # PHP Sock
            SOCK="/run/php/php$PHP_VER-fpm-$USER.sock"
            
            # SSL Paths
            CERT="/etc/letsencrypt/live/$DOM/fullchain.pem"
            KEY="/etc/letsencrypt/live/$DOM/privkey.pem"
            
            VHOST="/etc/nginx/sites-available/$DOM"
            
            # Check if SSL is requested and certificates exist
            if [ "$SSL" == "1" ] && [ -f "$CERT" ] && [ -f "$KEY" ]; then
                # Generate SSL VHost
                cat > "$VHOST" << EOF
server {
    listen 80;
    server_name $DOM www.$DOM;
    return 301 https://\$host\$request_uri;
}

server {
    listen 443 ssl http2;
    server_name $DOM www.$DOM;
    root $DOCROOT;
    index index.php index.html index.htm default.html;

    client_max_body_size 2048M;
    
    # SSL Configuration
    ssl_certificate $CERT;
    ssl_certificate_key $KEY;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # Security headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    access_log /var/www/clients/$USER/logs/$DOM.access.log;
    error_log /var/www/clients/$USER/logs/$DOM.error.log;

    location / {
        try_files \$uri \$uri/ /index.php?\$args;
    }

    location ~ \.php$ {
        include snippets/fastcgi-php.conf;
        fastcgi_pass unix:$SOCK;
    }
    
    # Block sensitive files
    location ~ /\.(?!well-known) {
        deny all;
    }
}
EOF
            else
                # Generate Standard HTTP VHost
                cat > "$VHOST" << EOF
server {
    listen 80;
    server_name $DOM www.$DOM;
    root $DOCROOT;
    index index.php index.html index.htm default.html;

    client_max_body_size 2048M;
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    access_log /var/www/clients/$USER/logs/$DOM.access.log;
    error_log /var/www/clients/$USER/logs/$DOM.error.log;

    location / {
        try_files \$uri \$uri/ /index.php?\$args;
    }

    location ~ \.php$ {
        include snippets/fastcgi-php.conf;
        fastcgi_pass unix:$SOCK;
    }
    
    # Block sensitive files
    location ~ /\.(?!well-known) {
        deny all;
    }
}
EOF
                
                # If SSL requested but no cert, try to obtain one
                if [ "$SSL" == "1" ]; then
                    if command -v certbot >/dev/null 2>&1; then
                        certbot --nginx -d "$DOM" -d "www.$DOM" --non-interactive --agree-tos --email "$ADMIN_EMAIL" --redirect --quiet || true
                    fi
                fi
            fi
            
            # Create symlink if it doesn't exist
            if [ ! -L "/etc/nginx/sites-enabled/$DOM" ]; then
                ln -sf "$VHOST" "/etc/nginx/sites-enabled/"
            fi
            
            # Update PHP memory limit if specified
            MEM=$(mysql -N -s -e "SELECT memory_limit FROM php_config WHERE domain_id=$DOM_ID" "$DB_NAME" 2>/dev/null || echo "")
            if [ -n "$MEM" ]; then
                POOL="/etc/php/$PHP_VER/fpm/pool.d/$USER.conf"
                if [ -f "$POOL" ]; then
                    if grep -q "php_admin_value\[memory_limit\]" "$POOL"; then
                        sed -i "s/php_admin_value\[memory_limit\].*/php_admin_value[memory_limit] = $MEM/" "$POOL"
                    else
                        echo "php_admin_value[memory_limit] = $MEM" >> "$POOL"
                    fi
                fi
            fi
            
            # Reload services
            safe_nginx_reload
            systemctl reload "php$PHP_VER-fpm" 2>/dev/null || true
            
            log_action "Synced VHOST for $DOM (PHP $PHP_VER)"
            echo "VHost updated successfully"
        else
            echo "Unknown vhost-tool subcommand: $SUB"
            exit 1
        fi
        ;;

    # --------------------------------------------------------------------------
    # SERVICE CONTROL
    # --------------------------------------------------------------------------
    service-status)
        SERVICE="$2"
        systemctl is-active "$SERVICE" 2>/dev/null || echo "inactive"
        ;;
        
    service-control)
        # $2: op, $3: service
        OP="$2"
        SERVICE="$3"
        
        case "$OP" in
            start|stop|restart|reload)
                if [ "$SERVICE" == "php8.2-fpm" ] && [ "$OP" == "reload" ]; then
                    safe_reload_php
                elif [ "$SERVICE" == "nginx" ] && [ "$OP" == "reload" ]; then
                    safe_nginx_reload
                else
                    systemctl "$OP" "$SERVICE"
                fi
                ;;
            enable|disable)
                systemctl "$OP" "$SERVICE"
                ;;
            *)
                echo "Unknown operation: $OP"
                exit 1
                ;;
        esac
        
        log_action "Service $OP: $SERVICE"
        echo "Service operation completed"
        ;;

    # --------------------------------------------------------------------------
    # APP INSTALLER TOOL
    # --------------------------------------------------------------------------
    app-tool)
        ACTION="$2"
        APP="$3"
        DOM="$4"
        
        # Get User Info for Domain and DocRoot
        read USER PHP_VER SSL DOCROOT_DB <<< $(mysql -N -s -e "SELECT c.username, d.php_version, d.ssl_active, d.document_root FROM domains d JOIN clients c ON d.client_id=c.id WHERE d.domain='$DOM'" "$DB_NAME" 2>/dev/null || echo "")
        
        if [ -z "$USER" ]; then
            echo "User not found for domain: $DOM"
            exit 1
        fi
        
        # Determine DOCROOT
        DOCROOT=$(get_docroot "$USER" "$DOM" "$DOCROOT_DB")
        
        # Determine Project Root (Parent of public_html)
        PROJECT_ROOT=$(dirname "$DOCROOT")
        
        TMP="/tmp/install_${USER}_$(date +%s)"
        mkdir -p "$TMP"
        
        if [ "$ACTION" == "install" ]; then
            # $5: db_name, $6: db_user, $7: db_pass
            DB_NAME_VAL="$5"
            DB_USER_VAL="$6"
            DB_PASS="$7"
            
            validate_input "$DB_NAME_VAL" "db_name"
            validate_input "$DB_USER_VAL" "db_user"
            
            log_action "Starting App Install: $APP for $DOM ($USER) at $DOCROOT"
            
            # Mark as installing in database
            mysql -e "UPDATE app_installations SET status='installing' WHERE db_name='$DB_NAME_VAL'" "$DB_NAME" 2>/dev/null || true
            
            # 1. Create Database & User
            $0 mysql-tool create-db "$DB_NAME_VAL"
            $0 mysql-tool create-user "$DB_USER_VAL" "$DB_PASS" "$DB_NAME_VAL"
            
            # 2. Backup existing content
            if [ -d "$DOCROOT" ] && [ "$(ls -A $DOCROOT 2>/dev/null)" ]; then
                BACKUP_DIR="/var/www/clients/$USER/backups"
                mkdir -p "$BACKUP_DIR"
                tar -czf "$BACKUP_DIR/before_${APP}_$(date +%Y%m%d_%H%M%S).tar.gz" -C "$(dirname $DOCROOT)" "$(basename $DOCROOT)" 2>/dev/null || true
            fi
            
            # Clean DOCROOT
            rm -rf "$DOCROOT"/* "$DOCROOT"/.* 2>/dev/null || true
            
            case "$APP" in
                wordpress)
                    # WordPress Install
                    log_action "Installing WordPress for $DOM"
                    
                    if ! wget -q https://wordpress.org/latest.tar.gz -O "$TMP/wp.tar.gz"; then
                        log_action "App Install Failed: WordPress download error"
                        mysql -e "UPDATE app_installations SET status='failed' WHERE db_name='$DB_NAME_VAL'" "$DB_NAME" 2>/dev/null || true
                        exit 1
                    fi
                    
                    tar -xzf "$TMP/wp.tar.gz" -C "$TMP"
                    
                    if [ -d "$TMP/wordpress" ]; then
                        cp -r "$TMP/wordpress/"* "$DOCROOT/"
                        
                        # WordPress Configuration
                        WP_CONFIG="$DOCROOT/wp-config.php"
                        cp "$DOCROOT/wp-config-sample.php" "$WP_CONFIG"
                        
                        # Generate salts
                        SALT_KEYS=$(wget -q -O - https://api.wordpress.org/secret-key/1.1/salt/)
                        
                        # Configure wp-config.php
                        sed -i "s/database_name_here/$DB_NAME_VAL/" "$WP_CONFIG"
                        sed -i "s/username_here/$DB_USER_VAL/" "$WP_CONFIG"
                        sed -i "s/password_here/$DB_PASS/" "$WP_CONFIG"
                        sed -i "s/localhost/localhost/" "$WP_CONFIG"
                        
                        # Insert salts
                        if [ -n "$SALT_KEYS" ]; then
                            sed -i "/^define('AUTH_KEY'/,/^define('NONCE_SALT'/d" "$WP_CONFIG" 2>/dev/null || true
                            echo "$SALT_KEYS" >> "$WP_CONFIG"
                        fi
                        
                        # Set Site URL
                        if [ "$SSL" == "1" ]; then
                            PROTOCOL="https"
                        else
                            PROTOCOL="http"
                        fi
                        echo "" >> "$WP_CONFIG"
                        echo "define('WP_SITEURL', '$PROTOCOL://$DOM');" >> "$WP_CONFIG"
                        echo "define('WP_HOME', '$PROTOCOL://$DOM');" >> "$WP_CONFIG"
                        echo "define('FS_METHOD', 'direct');" >> "$WP_CONFIG"
                        
                        # Set Permissions
                        chown -R "$USER:www-data" "$DOCROOT"
                        find "$DOCROOT" -type d -exec chmod 755 {} \;
                        find "$DOCROOT" -type f -exec chmod 644 {} \;
                        chmod 640 "$WP_CONFIG"
                        
                        mysql -e "UPDATE app_installations SET status='active' WHERE db_name='$DB_NAME_VAL'" "$DB_NAME" 2>/dev/null || true
                        log_action "Installed WordPress for $DOM"
                    else
                        log_action "App Install Failed: WordPress extraction error"
                        mysql -e "UPDATE app_installations SET status='failed' WHERE db_name='$DB_NAME_VAL'" "$DB_NAME" 2>/dev/null || true
                    fi
                    ;;
                    
                laravel)
                    # Laravel Install
                    log_action "Installing Laravel for $DOM"
                    
                    # Check if composer is available
                    if ! command -v composer >/dev/null 2>&1; then
                        echo "Composer not found. Installing Laravel requires Composer."
                        mysql -e "UPDATE app_installations SET status='failed' WHERE db_name='$DB_NAME_VAL'" "$DB_NAME" 2>/dev/null || true
                        exit 1
                    fi
                    
                    # Install Laravel
                    if sudo -u "$USER" composer create-project --prefer-dist laravel/laravel "$TMP/laravel"; then
                        cp -r "$TMP/laravel/"* "$DOCROOT/"
                        cp -r "$TMP/laravel/."* "$DOCROOT/" 2>/dev/null || true
                        
                        # Configure .env
                        ENV_FILE="$DOCROOT/.env"
                        if [ -f "$DOCROOT/.env.example" ]; then
                            cp "$DOCROOT/.env.example" "$ENV_FILE"
                        fi
                        
                        sed -i "s/DB_DATABASE=laravel/DB_DATABASE=$DB_NAME_VAL/" "$ENV_FILE"
                        sed -i "s/DB_USERNAME=root/DB_USERNAME=$DB_USER_VAL/" "$ENV_FILE"
                        sed -i "s/DB_PASSWORD=/DB_PASSWORD=$DB_PASS/" "$ENV_FILE"
                        sed -i "s/APP_URL=http://localhost/APP_URL=http:\/\/$DOM/" "$ENV_FILE"
                        
                        # Set Permissions
                        chown -R "$USER:www-data" "$DOCROOT"
                        chmod -R 775 "$DOCROOT/storage" "$DOCROOT/bootstrap/cache"
                        
                        # Update Nginx to point to public directory
                        sed -i "s|root $DOCROOT;|root $DOCROOT/public;|" "/etc/nginx/sites-available/$DOM"
                        safe_nginx_reload
                        
                        mysql -e "UPDATE app_installations SET status='active' WHERE db_name='$DB_NAME_VAL'" "$DB_NAME" 2>/dev/null || true
                        log_action "Installed Laravel for $DOM"
                    else
                        mysql -e "UPDATE app_installations SET status='failed' WHERE db_name='$DB_NAME_VAL'" "$DB_NAME" 2>/dev/null || true
                    fi
                    ;;
                    
                codeigniter)
                    # CodeIgniter 4 Install
                    log_action "Installing CodeIgniter for $DOM"
                    
                    if wget -q https://github.com/codeigniter4/framework/archive/refs/tags/v4.4.4.zip -O "$TMP/ci.zip"; then
                        unzip -q "$TMP/ci.zip" -d "$TMP"
                        cp -r "$TMP/framework-4.4.4/"* "$DOCROOT/"
                        
                        # Configure .env
                        if [ -f "$DOCROOT/env" ]; then
                            cp "$DOCROOT/env" "$DOCROOT/.env"
                        fi
                        
                        sed -i "s/# database.default.database = ci4/database.default.database = $DB_NAME_VAL/" "$DOCROOT/.env"
                        sed -i "s/# database.default.username = root/database.default.username = $DB_USER_VAL/" "$DOCROOT/.env"
                        sed -i "s/# database.default.password = root/database.default.password = $DB_PASS/" "$DOCROOT/.env"
                        sed -i "s/# app.baseURL = ''/app.baseURL = 'http:\/\/$DOM'/" "$DOCROOT/.env"
                        sed -i "s/# CI_ENVIRONMENT = production/CI_ENVIRONMENT = development/" "$DOCROOT/.env"
                        
                        chown -R "$USER:$USER" "$DOCROOT"
                        chmod -R 775 "$DOCROOT/writable"
                        
                        # Update Nginx
                        sed -i "s|root $DOCROOT;|root $DOCROOT/public;|" "/etc/nginx/sites-available/$DOM"
                        safe_nginx_reload
                        
                        mysql -e "UPDATE app_installations SET status='active' WHERE db_name='$DB_NAME_VAL'" "$DB_NAME" 2>/dev/null || true
                        log_action "Installed CodeIgniter for $DOM"
                    else
                        mysql -e "UPDATE app_installations SET status='failed' WHERE db_name='$DB_NAME_VAL'" "$DB_NAME" 2>/dev/null || true
                    fi
                    ;;
                    
                react)
                    # React (Vite) Install
                    log_action "Installing React for $DOM"
                    
                    # Check if npm is available
                    if ! command -v npm >/dev/null 2>&1; then
                        echo "npm not found. Installing React requires Node.js/npm."
                        mysql -e "UPDATE app_installations SET status='failed' WHERE db_name='$DB_NAME_VAL'" "$DB_NAME" 2>/dev/null || true
                        exit 1
                    fi
                    
                    # Create React app
                    if sudo -u "$USER" npm create vite@latest "$TMP/react-app" -- --template react --quiet; then
                        cd "$TMP/react-app"
                        sudo -u "$USER" npm install --quiet
                        sudo -u "$USER" npm run build --quiet
                        
                        cp -r "$TMP/react-app/dist/"* "$DOCROOT/"
                        
                        chown -R "$USER:$USER" "$DOCROOT"
                        
                        # Update Nginx
                        sed -i "s|root $DOCROOT;|root $DOCROOT;|" "/etc/nginx/sites-available/$DOM"
                        safe_nginx_reload
                        
                        mysql -e "UPDATE app_installations SET status='active' WHERE db_name='$DB_NAME_VAL'" "$DB_NAME" 2>/dev/null || true
                        log_action "Installed React for $DOM"
                    else
                        mysql -e "UPDATE app_installations SET status='failed' WHERE db_name='$DB_NAME_VAL'" "$DB_NAME" 2>/dev/null || true
                    fi
                    ;;
                    
                *)
                    echo "Unknown application: $APP"
                    mysql -e "UPDATE app_installations SET status='failed' WHERE db_name='$DB_NAME_VAL'" "$DB_NAME" 2>/dev/null || true
                    exit 1
                    ;;
            esac
            
            # Cleanup
            rm -rf "$TMP"
            echo "Application installed successfully"
            
        elif [ "$ACTION" == "uninstall" ]; then
            # $5: db_name, $6: db_user
            DB_NAME_VAL="$5"
            DB_USER_VAL="$6"
            
            validate_input "$DB_NAME_VAL" "db_name"
            validate_input "$DB_USER_VAL" "db_user"
            
            log_action "Uninstalling App: $APP from $DOM ($USER)"
            
            # 1. Drop DB & User
            $0 mysql-tool delete-db "$DB_NAME_VAL"
            $0 mysql-tool delete-user "$DB_USER_VAL"
            
            # 2. Backup before deletion
            BACKUP_DIR="/var/www/clients/$USER/backups"
            mkdir -p "$BACKUP_DIR"
            tar -czf "$BACKUP_DIR/${APP}_uninstall_$(date +%Y%m%d_%H%M%S).tar.gz" -C "$(dirname $DOCROOT)" "$(basename $DOCROOT)" 2>/dev/null || true
            
            # 3. Remove application files
            rm -rf "$DOCROOT"/*
            rm -rf "$DOCROOT"/.* 2>/dev/null || true
            
            # 4. Restore Default Page
            create_default_index "$DOCROOT" "$DOM" "$USER"
            
            # 5. Reset Nginx root if needed
            sed -i "s|root $DOCROOT.*;|root $DOCROOT;|" "/etc/nginx/sites-available/$DOM"
            safe_nginx_reload
            
            log_action "Uninstallation Complete for $DOM"
            echo "Application uninstalled"
        else
            echo "Unknown app-tool action: $ACTION"
            exit 1
        fi
        ;;

    # --------------------------------------------------------------------------
    # SSH KEY MANAGEMENT
    # --------------------------------------------------------------------------
    ssh-key)
        SUB="$2"
        USER="$3"
        
        validate_input "$USER" "username"
        
        SSH_DIR="/var/www/clients/$USER/.ssh"
        AUTH_FILE="$SSH_DIR/authorized_keys"
        
        if [ ! -d "$SSH_DIR" ]; then
            mkdir -p "$SSH_DIR"
            chmod 700 "$SSH_DIR"
            chown "$USER:$USER" "$SSH_DIR"
        fi
        
        case "$SUB" in
            add)
                KEY="$4"
                if [ -z "$KEY" ]; then
                    echo "SSH key required"
                    exit 1
                fi
                
                # Validate key format (basic check)
                if ! [[ "$KEY" =~ ^(ssh-rsa|ssh-ed25519|ecdsa-sha2-nistp256|ecdsa-sha2-nistp384|ecdsa-sha2-nistp521) ]]; then
                    echo "Invalid SSH key format"
                    exit 1
                fi
                
                echo "$KEY" >> "$AUTH_FILE"
                chmod 600 "$AUTH_FILE"
                chown "$USER:$USER" "$AUTH_FILE"
                log_action "Added SSH Key for $USER"
                echo "SSH key added"
                ;;
                
            list)
                if [ -f "$AUTH_FILE" ]; then
                    cat -n "$AUTH_FILE"
                else
                    echo "No SSH keys found"
                fi
                ;;
                
            delete)
                LINE="$4"
                if [ -z "$LINE" ] || ! [[ "$LINE" =~ ^[0-9]+$ ]]; then
                    echo "Valid line number required"
                    exit 1
                fi
                
                if [ -f "$AUTH_FILE" ]; then
                    if [ "$(wc -l < "$AUTH_FILE")" -ge "$LINE" ]; then
                        sed -i "${LINE}d" "$AUTH_FILE"
                        log_action "Deleted SSH Key line $LINE for $USER"
                        echo "SSH key deleted"
                    else
                        echo "Line number out of range"
                        exit 1
                    fi
                else
                    echo "No SSH keys found"
                fi
                ;;
                
            *)
                echo "Unknown ssh-key subcommand: $SUB"
                exit 1
                ;;
        esac
        ;;

    # --------------------------------------------------------------------------
    # BACKUP SYSTEM
    # --------------------------------------------------------------------------
    backup)
        SUB="$2"
        USER="$3"
        
        validate_input "$USER" "username"
        
        BACKUP_DIR="/var/www/clients/$USER/backups"
        mkdir -p "$BACKUP_DIR"
        chown "$USER:$USER" "$BACKUP_DIR"
        chmod 750 "$BACKUP_DIR"
        
        case "$SUB" in
            create)
                TS=$(date +%Y%m%d_%H%M%S)
                FILE="$BACKUP_DIR/backup_$TS.tar.gz"
                
                log_action "Creating backup for $USER"
                
                # Create temporary directory for database dumps
                DB_TMP="/tmp/db_dump_$USER_$TS"
                mkdir -p "$DB_TMP"
                
                # 1. Dump all user databases
                CID=$(mysql -N -s -e "SELECT id FROM clients WHERE username='$USER'" "$DB_NAME" 2>/dev/null || echo "")
                if [ -n "$CID" ]; then
                    mysql -N -s -e "SELECT db_name FROM client_databases WHERE client_id=$CID" "$DB_NAME" 2>/dev/null | while read DB; do
                        if [ -n "$DB" ]; then
                            mysqldump --single-transaction --quick "$DB" > "$DB_TMP/$DB.sql" 2>/dev/null || true
                        fi
                    done
                fi
                
                # 2. Create backup archive
                tar -czf "$FILE" \
                    -C "/var/www/clients/$USER" domains \
                    -C "$DB_TMP" . \
                    2>/dev/null || true
                
                # 3. Add metadata
                echo "Backup created: $(date)" > "$BACKUP_DIR/backup_$TS.info"
                echo "User: $USER" >> "$BACKUP_DIR/backup_$TS.info"
                echo "Size: $(du -h "$FILE" | cut -f1)" >> "$BACKUP_DIR/backup_$TS.info"
                
                # Cleanup
                rm -rf "$DB_TMP"
                
                # Set ownership
                chown "$USER:$USER" "$FILE" "$BACKUP_DIR/backup_$TS.info"
                chmod 640 "$FILE"
                
                log_action "Created Backup for $USER: $FILE"
                echo "Backup created: $(basename "$FILE")"
                ;;
                
            list)
                if [ -d "$BACKUP_DIR" ]; then
                    find "$BACKUP_DIR" -name "backup_*.tar.gz" -type f -exec basename {} \; | sort -r | head -20
                else
                    echo "No backups found"
                fi
                ;;
                
            restore)
                FILE="$BACKUP_DIR/$4"
                if [ ! -f "$FILE" ]; then
                    echo "Backup file not found: $4"
                    exit 1
                fi
                
                log_action "Restoring backup for $USER: $4"
                
                # Extract to temporary location first
                RESTORE_TMP="/tmp/restore_$USER_$(date +%s)"
                mkdir -p "$RESTORE_TMP"
                
                tar -xzf "$FILE" -C "$RESTORE_TMP"
                
                # Restore files
                if [ -d "$RESTORE_TMP/domains" ]; then
                    rsync -a "$RESTORE_TMP/domains/" "/var/www/clients/$USER/domains/"
                fi
                
                # Restore databases
                if [ -d "$RESTORE_TMP" ] && [ "$(ls -A $RESTORE_TMP 2>/dev/null | grep -v domains)" ]; then
                    for sql_file in "$RESTORE_TMP"/*.sql; do
                        if [ -f "$sql_file" ]; then
                            DB_NAME=$(basename "$sql_file" .sql)
                            mysql -e "CREATE DATABASE IF NOT EXISTS \`$DB_NAME\`;" 2>/dev/null || true
                            mysql "$DB_NAME" < "$sql_file" 2>/dev/null || true
                        fi
                    done
                fi
                
                # Fix permissions
                chown -R "$USER:$USER" "/var/www/clients/$USER/domains"
                find "/var/www/clients/$USER/domains" -type d -exec chmod 755 {} \;
                find "/var/www/clients/$USER/domains" -type f -exec chmod 644 {} \;
                
                # Cleanup
                rm -rf "$RESTORE_TMP"
                
                log_action "Restored Backup for $USER: $4"
                echo "Backup restored"
                ;;
                
            *)
                echo "Unknown backup subcommand: $SUB"
                exit 1
                ;;
        esac
        ;;

    # --------------------------------------------------------------------------
    # LOG VIEWER (Security)
    # --------------------------------------------------------------------------
    get-logs)
        TYPE="$2"
        LINES="${3:-50}"
        
        if ! [[ "$LINES" =~ ^[0-9]+$ ]]; then
            LINES=50
        fi
        
        case "$TYPE" in
            auth)
                if [ -f "/var/log/auth.log" ]; then
                    tail -n "$LINES" /var/log/auth.log
                else
                    echo "Auth log not found"
                fi
                ;;
            web)
                if [ -f "/var/log/nginx/error.log" ]; then
                    tail -n "$LINES" /var/log/nginx/error.log
                else
                    echo "Nginx error log not found"
                fi
                ;;
            sys)
                if [ -f "/var/log/syslog" ]; then
                    tail -n "$LINES" /var/log/syslog
                else
                    echo "System log not found"
                fi
                ;;
            *)
                echo "Unknown log type: $TYPE"
                exit 1
                ;;
        esac
        ;;

    get-stats)
        CPU=$(top -bn1 | grep "Cpu(s)" | awk '{print 100 - $8"%"}')
        RAM=$(free -m | awk '/Mem:/ {printf "%.1f%%", $3/$2 * 100}')
        DISK=$(df -h / | awk 'NR==2 {print $5}')
        UPTIME=$(uptime -p | sed 's/up //')
        LOAD=$(uptime | awk -F'load average:' '{print $2}' | sed 's/^\s*//')
        echo "CPU: $CPU|RAM: $RAM|Disk: $DISK|Uptime: $UPTIME|Load: $LOAD"
        ;;

    get-client-logs)
        # $2: user, $3: lines (optional)
        USER="$2"
        LINES="${3:-50}"
        
        validate_input "$USER" "username"
        
        if ! [[ "$LINES" =~ ^[0-9]+$ ]]; then
            LINES=50
        fi
        
        ERROR_LOG="/var/www/clients/$USER/logs/error.log"
        ACCESS_LOG="/var/www/clients/$USER/logs/access.log"
        
        if [ -f "$ERROR_LOG" ]; then
            echo "=== Error Log (last $LINES lines) ==="
            tail -n "$LINES" "$ERROR_LOG"
        fi
        
        if [ -f "$ACCESS_LOG" ] && [ "$LINES" -le 1000 ]; then
            echo ""
            echo "=== Access Log (last $LINES lines) ==="
            tail -n "$LINES" "$ACCESS_LOG"
        fi
        ;;

    clear-client-logs)
        # $2: user
        USER="$2"
        
        validate_input "$USER" "username"
        
        LOG_FILE="/var/www/clients/$USER/logs/error.log"
        
        if [ -f "$LOG_FILE" ]; then
            # Archive current log
            if [ -s "$LOG_FILE" ]; then
                ARCHIVE="/var/www/clients/$USER/logs/error_$(date +%Y%m%d_%H%M%S).log"
                cp "$LOG_FILE" "$ARCHIVE"
                chown "$USER:$USER" "$ARCHIVE"
                chmod 640 "$ARCHIVE"
            fi
            
            # Clear log
            truncate -s 0 "$LOG_FILE"
            echo "Logs cleared and archived"
        else
            echo "No log to clear"
        fi
        ;;

    # --------------------------------------------------------------------------
    # TRAFFIC MONITORING
    # --------------------------------------------------------------------------
    update-traffic-stats)
        log_action "Updating traffic statistics"
        
        # Use awstats or custom parsing
        if command -v awstats >/dev/null 2>&1; then
            # Use awstats if available
            awstats -update -config=default
        else
            # Simple log parsing
            mysql -N -s -e "SELECT id, username FROM clients" "$DB_NAME" 2>/dev/null | while read CID USER; do
                if [ -n "$CID" ] && [ -n "$USER" ]; then
                    LOG_FILE="/var/www/clients/$USER/logs/access.log"
                    if [ -f "$LOG_FILE" ]; then
                        # Get yesterday's date
                        YESTERDAY=$(date -d "yesterday" +%d/%b/%Y)
                        
                        # Parse log for yesterday
                        STATS=$(grep "\[$YESTERDAY" "$LOG_FILE" 2>/dev/null | awk '{count++; sum+=$10} END {print count, sum}')
                        HITS=$(echo "$STATS" | awk '{print $1}')
                        BYTES=$(echo "$STATS" | awk '{print $2}')
                        
                        [ -z "$HITS" ] && HITS=0
                        [ -z "$BYTES" ] && BYTES=0
                        
                        # Get all domains for this user
                        mysql -N -s -e "SELECT id FROM domains WHERE client_id=$CID" "$DB_NAME" 2>/dev/null | while read DID; do
                            if [ -n "$DID" ]; then
                                DATE_NOW=$(date +%Y-%m-%d)
                                mysql -e "INSERT INTO domain_traffic (domain_id, date, bytes_sent, hits) VALUES ($DID, '$DATE_NOW', $BYTES, $HITS) ON DUPLICATE KEY UPDATE bytes_sent=bytes_sent+$BYTES, hits=hits+$HITS;" "$DB_NAME" 2>/dev/null || true
                            fi
                        done
                    fi
                fi
            done
        fi
        
        log_action "Traffic stats updated"
        echo "Traffic statistics updated"
        ;;

    # --------------------------------------------------------------------------
    # TROUBLESHOOTING TOOL
    # --------------------------------------------------------------------------
    troubleshoot)
        SUB="$2"
        DOM_ID="$3"
        
        case "$SUB" in
            fix-perms)
                # Get User & Docroot
                read USER DOCROOT <<< $(mysql -N -s -e "SELECT c.username, d.document_root FROM domains d JOIN clients c ON d.client_id=c.id WHERE d.id=$DOM_ID" "$DB_NAME" 2>/dev/null || echo "")
                
                if [ -z "$USER" ] || [ -z "$DOCROOT" ]; then
                    echo "Domain not found"
                    exit 1
                fi
                
                if [ -d "$DOCROOT" ]; then
                    chown -R "$USER:$USER" "$DOCROOT"
                    find "$DOCROOT" -type d -exec chmod 755 {} \;
                    find "$DOCROOT" -type f -exec chmod 644 {} \;
                    usermod -a -G "$USER" www-data
                    log_action "Fixed Perms for $DOCROOT"
                    echo "Permissions fixed"
                fi
                ;;
                
            fix-default-page)
                read DOCROOT <<< $(mysql -N -s -e "SELECT document_root FROM domains WHERE id=$DOM_ID" "$DB_NAME" 2>/dev/null || echo "")
                
                if [ -z "$DOCROOT" ]; then
                    echo "Domain not found"
                    exit 1
                fi
                
                if [ -f "$DOCROOT/index.php" ] || [ -f "$DOCROOT/index.html" ]; then
                    if [ -f "$DOCROOT/default.html" ]; then
                        mv "$DOCROOT/default.html" "$DOCROOT/default.html.bak"
                        log_action "Hid default.html for $DOCROOT"
                        echo "Default page hidden"
                    fi
                fi
                ;;
                
            reload-services)
                read PHP_VER <<< $(mysql -N -s -e "SELECT php_version FROM domains WHERE id=$DOM_ID" "$DB_NAME" 2>/dev/null || echo "")
                
                safe_nginx_reload
                
                if [ -n "$PHP_VER" ]; then
                    systemctl reload "php$PHP_VER-fpm" 2>/dev/null || true
                else
                    safe_reload_php
                fi
                
                log_action "Reloaded Services (User Triggered)"
                echo "Services reloaded"
                ;;
                
            test-db)
                read USER <<< $(mysql -N -s -e "SELECT c.username FROM domains d JOIN clients c ON d.client_id=c.id WHERE d.id=$DOM_ID" "$DB_NAME" 2>/dev/null || echo "")
                
                if [ -n "$USER" ]; then
                    # Test MySQL connection
                    if mysql -e "SELECT 1" >/dev/null 2>&1; then
                        echo "MySQL: OK"
                    else
                        echo "MySQL: FAILED"
                    fi
                    
                    # Test user databases
                    CID=$(mysql -N -s -e "SELECT id FROM clients WHERE username='$USER'" "$DB_NAME" 2>/dev/null || echo "")
                    if [ -n "$CID" ]; then
                        echo "User databases:"
                        mysql -N -s -e "SELECT db_name FROM client_databases WHERE client_id=$CID" "$DB_NAME" 2>/dev/null | while read DB; do
                            if mysql -e "USE \`$DB\`; SELECT 1" >/dev/null 2>&1; then
                                echo "  $DB: OK"
                            else
                                echo "  $DB: FAILED"
                            fi
                        done
                    fi
                fi
                ;;
                
            *)
                echo "Unknown troubleshoot subcommand: $SUB"
                exit 1
                ;;
        esac
        ;;

    # --------------------------------------------------------------------------
    # MALWARE SCANNER (ClamAV)
    # --------------------------------------------------------------------------
    malware-scan)
        DID="$2"
        
        if [ -z "$DID" ]; then
            echo "Domain ID required"
            exit 1
        fi
        
        # Get Info
        read USER DOM <<< $(mysql -N -s -e "SELECT c.username, d.domain FROM domains d JOIN clients c ON d.client_id=c.id WHERE d.id=$DID" "$DB_NAME" 2>/dev/null || echo "")
        
        if [ -z "$USER" ] || [ -z "$DOM" ]; then
            echo "Domain not found"
            exit 1
        fi
        
        TARGET_DIR="/var/www/clients/$USER/domains/$DOM/public_html"
        
        if [ ! -d "$TARGET_DIR" ]; then
            echo "Directory not found: $TARGET_DIR"
            exit 1
        fi
        
        # Check if ClamAV is installed
        if ! command -v clamscan >/dev/null 2>&1; then
            echo "ClamAV not installed. Install with: apt-get install clamav"
            exit 1
        fi
        
        # Create scan record
        mysql -e "INSERT INTO malware_scans (domain_id, status, started_at) VALUES ($DID, 'scanning', NOW());" "$DB_NAME" 2>/dev/null || true
        SCAN_ID=$(mysql -N -s -e "SELECT LAST_INSERT_ID();" 2>/dev/null || echo "0")
        
        # Run scan in background
        (
            LOG_FILE="/tmp/clamscan_${DID}_$(date +%s).log"
            
            # Run scan
            clamscan -r --infected --no-summary "$TARGET_DIR" > "$LOG_FILE" 2>&1
            EXIT_CODE=$?
            
            # Parse results
            INFECTED=$(grep -c "FOUND" "$LOG_FILE" || echo "0")
            
            if [ $EXIT_CODE -eq 0 ]; then
                STATUS="clean"
                REPORT="No threats found. Scanned $(find "$TARGET_DIR" -type f | wc -l) files."
            elif [ $EXIT_CODE -eq 1 ]; then
                STATUS="infected"
                REPORT="Found $INFECTED infected files: $(grep "FOUND" "$LOG_FILE" | head -5 | sed 's/.* //' | tr '\n' ', ')"
            else
                STATUS="failed"
                REPORT="Scan error: exit code $EXIT_CODE"
            fi
            
            # Update database
            if [ "$SCAN_ID" != "0" ]; then
                SAFE_REPORT=$(echo "$REPORT" | sed "s/'/''/g")
                mysql -e "UPDATE malware_scans SET status='$STATUS', report='$SAFE_REPORT', infected_files=$INFECTED, finished_at=NOW() WHERE id=$SCAN_ID" "$DB_NAME" 2>/dev/null || true
            fi
            
            # Cleanup
            rm -f "$LOG_FILE"
            
        ) &
        
        echo "Scan started with ID: $SCAN_ID"
        log_action "Started Malware Scan for $DOM ($DID)"
        ;;

    # --------------------------------------------------------------------------
    # MAINTENANCE MODE
    # --------------------------------------------------------------------------
    maintenance)
        ACTION="$2"
        DOMAIN="$3"
        
        case "$ACTION" in
            on)
                if [ -z "$DOMAIN" ]; then
                    echo "Domain required"
                    exit 1
                fi
                
                VHOST="/etc/nginx/sites-available/$DOMAIN"
                if [ ! -f "$VHOST" ]; then
                    echo "VHost not found"
                    exit 1
                fi
                
                # Create maintenance page
                MAINT_DIR="/var/www/maintenance"
                mkdir -p "$MAINT_DIR"
                
                cat > "$MAINT_DIR/index.html" << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maintenance Mode</title>
    <style>
        body { margin: 0; padding: 0; font-family: system-ui, sans-serif; background: #f8fafc; color: #0f172a; display: flex; align-items: center; justify-content: center; height: 100vh; text-align: center; }
        .container { max-width: 600px; padding: 2rem; }
        h1 { color: #dc2626; font-size: 2.5rem; margin-bottom: 1rem; }
        p { color: #64748b; font-size: 1.125rem; line-height: 1.6; }
    </style>
</head>
<body>
    <div class="container">
        <h1> Maintenance Mode</h1>
        <p>We're currently performing scheduled maintenance. The site will be back online shortly.</p>
        <p>Thank you for your patience.</p>
    </div>
</body>
</html>
EOF
                
                # Backup original config
                cp "$VHOST" "$VHOST.backup"
                
                # Replace with maintenance config
                cat > "$VHOST" << EOF
server {
    listen 80;
    server_name $DOMAIN www.$DOMAIN;
    root /var/www/maintenance;
    index index.html;
    
    location / {
        try_files \$uri =503;
    }
    
    error_page 503 @maintenance;
    location @maintenance {
        return 503;
    }
}
EOF
                
                safe_nginx_reload
                echo "Maintenance mode enabled for $DOMAIN"
                ;;
                
            off)
                if [ -z "$DOMAIN" ]; then
                    echo "Domain required"
                    exit 1
                fi
                
                VHOST="/etc/nginx/sites-available/$DOMAIN"
                if [ ! -f "$VHOST.backup" ]; then
                    echo "No backup found for $DOMAIN"
                    exit 1
                fi
                
                # Restore original config
                mv "$VHOST.backup" "$VHOST"
                safe_nginx_reload
                echo "Maintenance mode disabled for $DOMAIN"
                ;;
                
            *)
                echo "Usage: $0 maintenance [on|off] domain"
                exit 1
                ;;
        esac
        ;;

    # --------------------------------------------------------------------------
    # SYSTEM INFO
    # --------------------------------------------------------------------------
    system-info)
        echo "=== SHM Panel System Information ==="
        echo "Date: $(date)"
        echo "Hostname: $(hostname -f)"
        echo "IP Address: $(hostname -I | awk '{print $1}')"
        echo "Uptime: $(uptime -p)"
        echo ""
        
        echo "=== Services ==="
        for service in nginx mysql php8.2-fpm bind9; do
            if systemctl is-active --quiet "$service"; then
                echo " $service: ACTIVE"
            else
                echo " $service: INACTIVE"
            fi
        done
        echo ""
        
        echo "=== Disk Usage ==="
        df -h / | awk 'NR==2 {print "Root: " $5 " used (" $3 "/" $2 ")"}'
        echo ""
        
        echo "=== Memory Usage ==="
        free -h | awk '/Mem:/ {print "RAM: " $3 "/" $2 " (" int($3/$2*100) "%)"}'
        echo ""
        
        echo "=== Active Accounts ==="
        mysql -N -s -e "SELECT COUNT(*) FROM clients WHERE status='active'" "$DB_NAME" 2>/dev/null || echo "Database error"
        echo ""
        
        echo "=== Recent Log Activity ==="
        tail -5 /var/log/shm-manage.log 2>/dev/null || echo "Log file not found"
        ;;

    # --------------------------------------------------------------------------
    # HELP
    # --------------------------------------------------------------------------
    help|--help|-h)
        cat << 'EOF'
SHM Panel Backend Management Tool

Usage: $0 COMMAND [ARGUMENTS...]

ACCOUNT MANAGEMENT:
  create-account USER DOMAIN EMAIL PASSWORD
  delete-account USER
  add-domain USER DOMAIN
  delete-domain USER DOMAIN
  suspend-account USER
  unsuspend-account USER
  reset-account USER
  fix-permissions USER

DATABASE:
  mysql-tool create-db DB_NAME
  mysql-tool create-user DB_USER DB_PASS DB_NAME
  mysql-tool delete-db DB_NAME
  mysql-tool reset-pass DB_USER NEW_PASS
  mysql-tool delete-user DB_USER

DNS:
  dns-tool sync DOMAIN_ID

VHOST:
  vhost-tool sync DOMAIN_ID

APPLICATIONS:
  app-tool install APP DOMAIN DB_NAME DB_USER DB_PASS
  app-tool uninstall APP DOMAIN DB_NAME DB_USER

SSH KEYS:
  ssh-key add USER KEY
  ssh-key list USER
  ssh-key delete USER LINE_NUMBER

BACKUP:
  backup create USER
  backup list USER
  backup restore USER FILE

LOGS:
  get-logs [auth|web|sys] [LINES]
  get-client-logs USER [LINES]
  clear-client-logs USER

MONITORING:
  get-stats
  update-traffic-stats

TROUBLESHOOTING:
  troubleshoot fix-perms DOMAIN_ID
  troubleshoot fix-default-page DOMAIN_ID
  troubleshoot reload-services DOMAIN_ID
  troubleshoot test-db DOMAIN_ID

SECURITY:
  malware-scan DOMAIN_ID

MAINTENANCE:
  maintenance [on|off] DOMAIN

SYSTEM:
  service-status SERVICE
  service-control [start|stop|restart|reload|enable|disable] SERVICE
  system-info

HELP:
  help
EOF
        ;;

    # --------------------------------------------------------------------------
    # DEFAULT CASE
    # --------------------------------------------------------------------------
    # --------------------------------------------------------------------------
    # SERVICE MANAGEMENT
    # --------------------------------------------------------------------------
    service-status)
        # $2: service name
        SRV="$2"
        if systemctl is-active --quiet "$SRV"; then
            echo "active"
        else
            echo "inactive"
        fi
        ;;

    service-control)
        # $2: operation, $3: service
        OP="$2"
        SRV="$3"
        
        if [[ "$OP" =~ ^(start|stop|restart|reload)$ ]]; then
            log_action "Service Control: $OP $SRV"
            systemctl "$OP" "$SRV"
            echo "Service $OP executed"
        else
            echo "Invalid operation"
            exit 1
        fi
        ;;

    # --------------------------------------------------------------------------
    # SYSTEM STATS
    # --------------------------------------------------------------------------
    get-stats)
        # Output: CPU%|RAM%|DISK%|LOAD
        
        # CPU Usage (approximate)
        CPU=$(grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage}')
        
        # RAM Usage
        RAM=$(free | grep Mem | awk '{print $3/$2 * 100.0}')
        
        # Disk Usage (Root)
        DISK=$(df -h / | awk 'NR==2 {print $5}' | tr -d '%')
        
        # Load Avg
        LOAD=$(cat /proc/loadavg | awk '{print $1}')
        
        printf "%.1f|%.1f|%s|%s\n" "$CPU" "$RAM" "$DISK" "$LOAD"
        ;;

    # --------------------------------------------------------------------------
    # DEFAULT CASE
    # --------------------------------------------------------------------------
    *)
        echo "Unknown command: $1"
        exit 1
        ;;
esac

# Clean exit
exit 0